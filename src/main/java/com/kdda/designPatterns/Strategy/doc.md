**策略模式（Strategy Pattern）** 是一种行为型设计模式，它通过定义一系列的算法或行为，将它们封装成独立的策略类，并使得这些策略可以互相替换。策略模式允许在运行时动态地选择不同的算法，而无需修改客户端代码。

核心思想：
将一组算法封装为独立的类，并使它们具有相同的接口，便于互相替换。
客户端可以根据需要选择不同的策略，而不需要改变算法的实现方式。
结构：
策略模式通常包含以下几个部分：

策略接口（Strategy Interface）：定义所有策略类共有的接口，所有具体策略类都需要实现这个接口。
具体策略类（Concrete Strategies）：每个具体策略类实现策略接口中的算法，代表不同的策略。
上下文类（Context）：持有策略接口的引用，负责与客户端交互，允许在运行时动态切换不同的策略。

策略模式的应用场景：
算法的多样性：当系统中有多个算法或行为时，客户端可以根据不同的条件选择不同的策略。
动态替换算法：运行时需要更换算法，而不希望在客户端代码中直接进行切换。
避免使用条件语句：不希望通过复杂的 if-else 或 switch-case 来处理多个分支时，可以将算法封装成策略类，简化代码。

优点：
开闭原则：添加新的策略不需要修改已有代码，扩展性好。
消除条件判断：避免大量的条件语句来决定使用哪种算法。
灵活性高：可以在运行时动态选择和替换策略。
缺点：
增加类的数量：每个策略都需要一个具体类，可能导致类数量增加。
客户端必须了解不同的策略：客户端必须知道有哪些策略可用，才能正确选择。
策略模式非常适合需要在运行时选择不同行为或算法的场景。